<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>攻略同期ツール 最終安定版</title>
    <style>
        body { display: flex; flex-direction: column; height: 100vh; margin: 0; font-family: sans-serif; background: #121212; color: #fff; overflow: hidden; }
        #header { padding: 15px; background: #222; display: flex; gap: 10px; border-bottom: 2px solid #333; align-items: flex-end; }
        .input-group { display: flex; flex-direction: column; gap: 4px; }
        label { font-size: 10px; color: #aaa; }
        input { padding: 8px; border-radius: 4px; border: 1px solid #444; background: #333; color: #fff; width: 180px; font-size: 12px; }
        button { cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; padding: 8px 15px; font-weight: bold; }
        
        #main-container { display: flex; flex: 1; overflow: hidden; }
        #video-section { flex: 1.2; position: relative; display: flex; flex-direction: column; background: #000; }
        #sheet-section { flex: 1; border-left: 2px solid #333; background: #fff; }
        iframe { width: 100%; height: 100%; border: none; }

        /* 同期表示エリア */
        #sync-overlay { background: rgba(0, 0, 0, 0.9); padding: 20px; border-top: 4px solid #007bff; }
        .phase-label { color: #4fc3f7; font-size: 16px; margin-bottom: 4px; font-weight: bold; }
        .gimmick-label { color: #fff; font-size: 32px; font-weight: bold; line-height: 1.2; }
        .time-label { color: #ffeb3b; font-family: monospace; font-size: 24px; margin-right: 20px; border: 1px solid #ffeb3b; padding: 2px 8px; border-radius: 4px; }
        #current-info { display: flex; align-items: center; }
        #status-bar { font-size: 11px; color: #888; margin-top: 5px; background: #000; padding: 2px 10px; }
    </style>
</head>
<body>

<div id="header">
    <div class="input-group">
        <label>1. シートURL (pubhtml または 通常URL)</label>
        <input type="text" id="sheetUrl" placeholder="URLを貼り付け" value="">
    </div>
    <div class="input-group">
        <label>2. YouTube ID</label>
        <input type="text" id="videoId" placeholder="例: dQw4w9WgXcQ" value="">
    </div>
    <div class="input-group">
        <label>3. 戦闘開始(動画内時間)</label>
        <input type="text" id="startTimeInput" placeholder="例 1:20" value="0:00">
    </div>
    <button onclick="startApp()">同期開始</button>
</div>

<div id="main-container">
    <div id="video-section">
        <div id="player"></div>
        <div id="sync-overlay">
            <div id="phase-display" class="phase-label">PHASE: ---</div>
            <div id="current-info">
                <span id="time-display" class="time-label">0:00</span>
                <span id="gimmick-display" class="gimmick-label">待機中</span>
            </div>
        </div>
        <div id="status-bar">データ未読込</div>
    </div>
    <div id="sheet-section">
        <iframe id="sheetFrame" src="about:blank"></iframe>
    </div>
</div>

<script>
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    document.head.appendChild(tag);

    var player, offsetSeconds = 0, timerInterval;
    var timelineData = [];

    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            height: '100%', width: '100%', videoId: '',
            events: { 'onStateChange': (e) => { if(e.data == 1) runLoop(); else clearInterval(timerInterval); } }
        });
    }

    async function startApp() {
        let url = document.getElementById('sheetUrl').value.trim();
        const vid = document.getElementById('videoId').value.trim();
        const start = document.getElementById('startTimeInput').value.trim();

        if(!url || !vid) return alert("URLとIDを入力してください");

        // --- 1. 表示用URLの作成 (iframe用) ---
        let displayUrl = url;
        if (!url.includes('pubhtml')) {
            // 通常の編集URLの場合、閲覧用(preview)に変換してiframeで見やすくする
            displayUrl = url.replace(/\/edit.*$/, "/preview");
        }
        document.getElementById('sheetFrame').src = displayUrl;

        // --- 2. データ取得用URLの作成 (CSV形式) ---
        let csvUrl = "";
        if (url.includes('pubhtml')) {
            csvUrl = url.replace(/\/pubhtml.*/, "/pub?output=csv");
        } else {
            // 通常のURL (https://docs.google.com/spreadsheets/d/ID/edit...) からIDを抽出
            const match = url.match(/\/d\/([^\/]+)/);
            if (match) {
                const id = match[1];
                // gid（シート識別子）も抽出を試みる
                const gidMatch = url.match(/gid=([0-9]+)/);
                const gid = gidMatch ? `&gid=${gidMatch[1]}` : "";
                csvUrl = `https://docs.google.com/spreadsheets/d/${id}/export?format=csv${gid}`;
            }
        }

        // 動画とオフセット設定
        player.loadVideoById(vid);
        offsetSeconds = timeToSec(start);

        // --- 3. データの取得と解析 ---
        try {
            const res = await fetch(csvUrl);
            const csvText = await res.text();
            
            // CSVを正確に1行ずつ分割
            const rows = csvText.split(/\r?\n/);
            timelineData = [];

            // 31行目（index 30）から処理
            for (let i = 30; i < rows.length; i++) {
                // カンマ区切りの解析（セル内のカンマに対応）
                const cols = parseCSVLine(rows[i]);
                
                if (cols && cols.length >= 5) {
                    const phase = cols[1];   // B列
                    const timeStr = cols[3]; // D列
                    const gimmick = cols[4]; // E列
                    
                    const sec = timeToSec(timeStr);
                    if (sec !== null) {
                        timelineData.push({ sec: sec, phase: phase, gimmick: gimmick });
                    }
                }
            }
            
            timelineData.sort((a, b) => a.sec - b.sec);
            document.getElementById('status-bar').innerText = `読込成功: ${timelineData.length}件のデータを取得 (31行目以降)`;
            
        } catch (e) { 
            document.getElementById('status-bar').innerText = "エラー: スプレッドシートを「ウェブに公開」するか、「リンクを知っている人全員が閲覧可」にしてください。";
        }
    }

    // CSVの1行を配列に分解する関数（引用符対応）
    function parseCSVLine(line) {
        const result = [];
        let cur = "";
        let inQuote = false;
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                inQuote = !inQuote;
            } else if (char === ',' && !inQuote) {
                result.push(cur.trim());
                cur = "";
            } else {
                cur += char;
            }
        }
        result.push(cur.trim());
        return result;
    }

    function timeToSec(str) {
        if(!str || !str.includes(':')) return null;
        const p = str.trim().split(':').map(Number);
        if(p.some(isNaN)) return null;
        if(p.length === 2) return p[0] * 60 + p[1];
        if(p.length === 3) return p[0] * 3600 + p[1] * 60 + p[2];
        return null;
    }

    function runLoop() {
        if(timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            const now = player.getCurrentTime();
            const combatTime = now - offsetSeconds;

            const displayMin = Math.floor(Math.max(0, combatTime) / 60);
            const displaySec = Math.floor(Math.max(0, combatTime) % 60);
            document.getElementById('time-display').innerText = `${displayMin}:${displaySec.toString().padStart(2,'0')}`;

            let current = null;
            for(let item of timelineData) {
                if(combatTime >= item.sec) current = item;
                else break;
            }

            if(current) {
                document.getElementById('phase-display').innerText = `PHASE: ${current.phase || '---'}`;
                document.getElementById('gimmick-display').innerText = current.gimmick || '---';
            }
        }, 200);
    }
</script>
</body>
</html>